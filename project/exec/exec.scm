;; The skeleton of an interpreter for the While language (with break).

(define eval_expr
  (lambda (exp store)
    (cond ((number? exp) exp)
	  ((symbol? exp) (value_of (assoc exp store)))
	  ((neg? exp) (- (eval_expr exp store)))
	  ((sum? exp)
	   (+ (eval_expr (subexp1 exp) store)
	      (eval_expr (subexp2 exp) store)))
	  ((difference? exp)
	   (- (eval_expr (subexp1 exp) store)
	      (eval_expr (subexp2 exp) store)))
	  ((product? exp)
	   (* (eval_expr (subexp1 exp) store)
	      (eval_expr (subexp2 exp) store)))
	  ((quotient? exp)
	   (/ (eval_expr (subexp1 exp) store)
	      (eval_expr (subexp2 exp) store)))
	  ((remainder? exp)
	   (mod (eval_expr (subexp1 exp) store)
		(eval_expr (subexp2 exp) store)))
	  (else (error 'eval_expr "invalid expression ~s" exp)))))

;; The following functions test the operation of arithmetic expressions

(define sum?
  (lambda (exp) (eq? (cadr exp) '+)))

(define difference?
  (lambda (exp) (eq? (cadr exp) '-)))

(define product?
  (lambda (exp) (eq? (cadr exp) '*)))

(define quotient?
  (lambda (exp) (eq? (cadr exp) '/)))

(define neg?
  (lambda (exp) (eq? (car exp) 'neg)))

(define remainder?
  (lambda (exp) (eq? (cadr exp) '%)))

(define value_of
  (lambda (pair) (cadr pair)))

;; The following are functions to retrieve the appropriate subexpressions
;; from an arithmetic expression

(define subexp1
  (lambda (exp) (caddr exp)))

(define subexp2
  (lambda (exp) (cadddr exp)))

;;; The core of the statement interpreter in continuation-style passing.
;;; All recursive calls to exec_stmt is tail recursive.

(define exec_stmt
  (lambda (stmt rest store continuation)
    (cond ((null? stmt) store)
	  ((assign? stmt) ...)
	  ((sequence? stmt) ...)
	  ((if1? stmt) ...)
	  ((if2? stmt) ...)
	  ((while? stmt) ...)
	  ((break? stmt) ...)
	  (else (error 'exec_stmt "invalid statment ~s" stmt)))
    )
  )

;;; various accessors
(define assign? (lambda (s) (eq? (car s) 'assign)))
(define skip? (lambda (s) (eq? s 'skip)))
(define sequence? (lambda (s) (list? (car s))))
(define if1? (lambda (s) (eq? (car s) 'if1)))
(define if2? (lambda (s) (eq? (car s) 'if1)))
(define while? (lambda (s) (eq? (car s) 'while)))
(define break? (lambda (s) (eq? (car s) 'break)))


;;; Bring in the parse tree and interpret it.

(define compute
  (lambda ()
    (load "scheme_ast")  ;; << This needs to be consistent
                         ;; << with the file generated by ast.exe
      (exec_stmt ptree '() '() '())))
